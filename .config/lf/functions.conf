# ~/.config/lf/functions.conf
# Custom Functions
#
cmd mkdir %{{
    printf "Directory name: "
    read -r dirname
    mkdir -p "$dirname"
    lf -remote "send $id select \"$dirname\""
}}

cmd mkfile %{{
    printf "File name: "
    read -r filename
    touch "$filename"
    lf -remote "send $id select \"$filename\""
}}

# Enhanced copy with progress
cmd copy_progress ${{
    set -f
    if [ -n "$fs" ]; then
        rsync -av --progress "$fs" . \
        | stdbuf -i0 -o0 -e0 tr '\r' '\n' \
        | while read -r line; do
            lf -remote "send $id echo $line"
        done
    fi
}}

# Improved search functionality with fzf - searches files and directories recursively
cmd fzf_search ${{
    RG_PREFIX="rg --files-with-matches --hidden --glob '!.git/' --color=always --smart-case "
    
    if command -v fzf >/dev/null 2>&1; then
        # If ripgrep is available, use it for better results
        if command -v rg >/dev/null 2>&1; then
            res=$(
                FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
                fzf --bind "change:reload:$RG_PREFIX {q} || true" \
                    --ansi --layout=reverse --header 'Search files/directories' \
                    --preview 'if [[ -d {} ]]; then ls -la --color=always {}; else bat --color=always --style=numbers --line-range=:100 {} 2>/dev/null || cat {} 2>/dev/null || echo Binary file; fi'
            )
        else
            # Fall back to find if ripgrep is not available
            res=$(find . -type f -o -type d 2>/dev/null | fzf --layout=reverse --header 'Search files/directories' \
                --preview 'if [[ -d {} ]]; then ls -la --color=always {}; else bat --color=always --style=numbers --line-range=:100 {} 2>/dev/null || cat {} 2>/dev/null || echo Binary file; fi')
        fi
        
        # Handle the selected result
        if [ -n "$res" ]; then
            if [ -f "$res" ]; then
                cmd="select"
            elif [ -d "$res" ]; then
                cmd="cd"
            fi
            lf -remote "send $id $cmd \"$res\""
        fi
    else
        echo "fzf is not installed. Using find instead."
        printf "Search pattern: "
        read -r pattern
        res="$(find . -iname "*${pattern}*" | head -n 1)"
        [ -n "$res" ] && lf -remote "send $id select \"$res\""
    fi
}}

# Custom open command that prompts for the program to use
cmd open_with %{{
    set -f
    printf "Open with: "
    read -r program
    
    if command -v "$program" >/dev/null 2>&1; then
        for file in $fx; do
            # Run the program asynchronously
            $program "$file" > /dev/null 2>&1 &
        done
    else
        echo "Error: Program '$program' not found."
    fi
}}

# Override default open command to offer choices
# cmd open ${{
#     case $(file --mime-type "$f" -b) in
#         text/*|application/json|application/javascript|application/x-shellscript) $EDITOR "$f";;
#         application/pdf) zathura "$f" > /dev/null 2>&1 & ;;
#         image/*) sxiv "$f" > /dev/null 2>&1 & ;;
#         audio/*) mpv --audio-display=no "$f" > /dev/null 2>&1 & ;;
#         video/*) mpv "$f" > /dev/null 2>&1 & ;;
#         *) 
#             printf "Choose how to open:\n1) Default\n2) Custom program\nEnter choice: "
#             read -r choice
#             case "$choice" in
#                 1) xdg-open "$f" > /dev/null 2>&1 & ;;
#                 2) lf -remote "send $id open_with" ;;
#                 *) echo "Invalid choice" ;;
#             esac
#             ;;
#     esac
# }}
#
# Enhanced remove to trash with date-based organization
cmd trash ${{
    set -f
    date_dir="$HOME/.trash/$(date +%Y-%m)"
    mkdir -p "$date_dir"
    for file in $fx; do
        if [ -e "$file" ]; then
            mv -- "$file" "$date_dir/" && echo "Trashed: $file to $date_dir"
        else
            echo "Error: File '$file' does not exist."
        fi
    done
}}

# Improved bulk-rename with backup
cmd bulk-rename ${{
    old=$(mktemp)
    new=$(mktemp)
    [ -n "$fs" ] && fs=$(basename -a $fs) || fs=$(ls)
    printf '%s\n' "$fs" > "$old"
    printf '%s\n' "$fs" > "$new"
    $EDITOR "$new"
    [ "$(wc -l < "$old")" -eq "$(wc -l < "$new")" ] || { rm -f "$old" "$new"; exit 1; }
    backup_dir="$HOME/.local/share/lf/rename_backup/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    paste "$old" "$new" | while IFS= read -r names; do
        src=$(printf '%s' "$names" | cut -f1)
        dst=$(printf '%s' "$names" | cut -f2)
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then continue; fi
        cp -r -- "$src" "$backup_dir/"
        mv -- "$src" "$dst"
    done
    rm -f "$old" "$new"
    lf -remote "send $id unselect"
}}

# Enhanced archive extraction with progress
cmd extract ${{
    set -f
    dir="${f%.*}"
    mkdir -p "$dir"
    case "$f" in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjf "$f" -C "$dir" ;;
        *.tar.gz|*.tgz) tar xzf "$f" -C "$dir" ;;
        *.tar.xz|*.txz) tar xJf "$f" -C "$dir" ;;
        *.tar) tar xf "$f" -C "$dir" ;;
        *.gz) cp "$f" "$dir" && cd "$dir" && gunzip "$f" ;;
        *.bz2) cp "$f" "$dir" && cd "$dir" && bunzip2 "$f" ;;
        *.zip) unzip "$f" -d "$dir" ;;
        *.rar) unrar x "$f" "$dir" ;;
        *.7z) 7z x "$f" -o"$dir" ;;
        *.Z) cp "$f" "$dir" && cd "$dir" && uncompress "$f" ;;
        *.tar.lz) tar xf "$f" -C "$dir" ;;
        *.lz) cp "$f" "$dir" && cd "$dir" && lzip -d "$f" ;;
        *.lzma) cp "$f" "$dir" && cd "$dir" && unlzma "$f" ;;
        *.xz) cp "$f" "$dir" && cd "$dir" && unxz "$f" ;;
        *) echo "Unsupported format" ;;
    esac
}}

# Improved compress with options
cmd compress ${{
    set -f
    printf "Archive name: "
    read -r name
    printf "Available formats:\n1) .zip\n2) .tar.gz\n3) .7z\n4) .rar\nEnter number: "
    read -r choice

    case "$choice" in
        1)
            dir="${name}_zip"
            ext="zip"
            mkdir -p "$dir"
            cp -r $fx "$dir" && zip -r "$name.$ext" "$dir" && rm -r "$dir"
            ;;
        2)
            dir="${name}_tar"
            ext="tar.gz"
            mkdir -p "$dir"
            cp -r $fx "$dir" && tar czf "$name.$ext" "$dir" && rm -r "$dir"
            ;;
        3)
            7z a "$name.7z" $fx
            ;;
        4)
            dir="${name}_rar"
            mkdir -p "$dir"
            cp -r $fx "$dir" && rar a "$name.rar" "$dir" && rm -r "$dir"
            ;;
        *)
            echo "Invalid choice"
            exit 1
            ;;
    esac

    if [ $? -eq 0 ]; then
        echo "Successfully compressed"
    else
        echo "Compression failed"
    fi
}}

# Quick preview using standard Unix tools
cmd preview ${{
    file="$f"
    if [ -d "$file" ]; then
        ls -lh --color=always "$file"
    else
        case "$file" in
            *.md|*.txt|*.log)
                head -n 100 "$file" ;;
            *.json)
                cat "$file" | sed 's/,/,\n/g' | sed 's/{/{\n/g' | sed 's/}/\n}/g' ;;
            *.csv)
                column -t -s, "$file" | head -n 100 ;;
            *.tar.gz|*.tgz)
                tar tzf "$file" ;;
            *.zip)
                unzip -l "$file" ;;
            *.rar)
                unrar l "$file" ;;
            *.7z)
                7z l "$file" ;;
            *)
                file -b "$file"
                echo "────────────────"
                head -n 100 "$file" 2>/dev/null ;;
        esac
    fi
}}
